 --- title: Svelte 5 migration guide --- Version 5 comes with overhauled syntax and reactivity system. look different at first, soon notice many similarities. guide goes over changes in detail shows how to upgrade., provide information on _why_ we did these changes. don't have to migrate to new syntax right - Svelte 5 still supports old Svelte 4 syntax, can mix and match components using new syntax with components old and vice versa. expect many people to to upgrade with few lines of code changed initially. [migration script](#Migration-script) helps with steps automatically. ## Reactivity syntax changes At heart of Svelte 5 is new runes API. Runes are compiler instructions inform Svelte about reactivity. Syntactically, runes are functions starting with dollar-sign. ### let -> $state In Svelte 4, `let` declaration at top level of component was implicitly reactive. In Svelte 5, things more explicit: variable is reactive when created using `$state` rune. migrate counter to runes mode by wrapping counter in `$state`: ```svelte <script> let count =$state(0); </script> ``` Nothing else changes. `count` is still number itself, read and write directly to it, without wrapper like `. value` or `getCount()`. > `let` being implicitly reactive at top level worked great, but meant reactivity constrained - `let` declaration anywhere else not reactive. forced to resort to using stores when refactoring code out of top level of components for reuse. meant to learn separate reactivity model, result often wasn't as nice to workreactivity explicit in Svelte 5, can keep using same API outside top level of components. Head to [the tutorial](/tutorial) to learn more. ### $: -> $derived/$effect In Svelte 4, `$:` statement at top level of component used to declare derivation, i. e state defined through computation of other state. In Svelte 5, achieved using `$derived` rune: ```svelte <script> let count =$state(0); $:constdouble =$derived(count * 2); </script> ``` As with `$state`, nothing else changes. `double` is still number itself, read it directly, without wrapper like `. value` or `getDouble()`. `$:` statement used to create side effects. In Svelte 5, achieved using `$effect` rune: ```svelte <script> let count =$state(0); $:$effect(() =>{ if (count > 5) { alert('Count is too high!'); } }); </script> Note [when `$effect` runs different]($effect#Understanding-dependencies) than when `$:` runs. > `$:` was great shorthand easy to get started with: slap `$:` in front of most code it would work. intuitiveness drawback more complicated code became, wasn't easy to reason about. intent of code to create derivation, or side effect? With `$derived` and `$effect`, more up-front decision making to do (spoiler alert: 90% of time you want `$derived`), but future-you and other developers on team have easier time.> > were gotchas hard to spot: > - `$:` only updated directly before rendering, meant could read stale values in-between rerenders - `$:` only ran once per tick, statements may run less often than - `$:` dependencies determined through static analysis of dependencies. This worked in most cases, but could break in subtle ways during refactoring where dependencies for moved into function no longer visible result > `$:` statements also ordered by using static analysis of dependencies. In some cases could be ties ordering be wrong result, needing manual interventions. Ordering could break while refactoring code some dependencies no longer visible result. > Lastly, it wasn't TypeScript-friendly (our editor tooling had to jump through hoops to make it valid for TypeScript), blocker for making Svelte's reactivity model universal. > > `$derived` and `$effect` fix all these by - always returning latest value > running as often as needed to be stable determining dependencies at runtime, immune to refactorings executing dependencies as needed immune to ordering problems > being TypeScript-friendly ### export let -> $props In Svelte 4, properties of component declared using `export let`. Each property was one declaration. In Svelte 5, all properties declared through `$props` rune, through destructuring: ```svelte <script> export let optional = 'unset'; export let required; let { optional = 'unset', required } = $props(); </script> ``` multiple cases where declaring properties becomes less straightforward than few `export let` declarations: - you want to rename property, for example because name is a reserved identifier (e. g.`class`) - don't know other properties to expect in advance want to forward every property to another component cases need special syntax in Svelte 4: renaming: `export { klass as class}` other properties: `$$restProps` - all properties `$$props` In Svelte 5, `$props` rune makes this straightforward without additional Svelte-specific syntax: renaming: use property renaming `let { class: klass } = $props();` other properties: use spreading `let { foo, bar,. rest } = $props();` all properties: don't destructure `let props = $props();` ```svelte <script> let klass = ''; export { klass as class}; let { class: klass,. rest } = $props(); </script> <button class={klass} {. $$restPropsrest}>click me</button> `` `export let` controversial API decisions, debate about property `export`ed or `import`ed. `$props` doesn't have this trait. in line with other runes, general thinking reduces to "everything special to reactivity in Svelte is a rune". limitations around `export let`, required additional API, shown. `$props` unite this in one syntactical concept leans on regular JavaScript destructuring syntax. ## Event changes Event handlers given facelift in Svelte 5. in Svelte 4 use `on:` directive to attach event listener to element, in Svelte 5 they are properties like any other (in remove colon): ```svelte <script> let count = $state(0); </script> <button on:click={() => count++}> clicks: {count} </button> `` Since they're just properties, use normal shorthand syntax.`svelte <script> let count = $state(0); function onclick() { count++; } </script <button {onclick}> clicks: {count}. using named event handler function better to use descriptive name. Component events In Svelte 4, components could emit events creating dispatcher with `createEventDispatcher`. function deprecated in Svelte 5., components should accept _callback props_ pass functions as properties to components`svelte!file App. svelte> <script import Pump from. /Pump. svelte' size = $state(15); burst = $state(false); function reset() { size = 15; burst = false; </script> <Pump on:inflate={(power) => { size += power. detail; if (size > 75) burst = true; on:deflate={(power) => { if (size > 0) size -= power. detail; {#if burst} <button onclick={reset}>new balloon</button> <span class="boom">ðŸ’¥</span>:else <span class="balloon" style="scale: {0. 01 * size}"> ðŸŽˆ {/if`svelte!file Pump.svelte> <script> import { createEventDispatcher } from 'svelte'; const dispatch = createEventDispatcher(); let { inflate, deflate } = $props(); let power = $state(5); </script> <button onclick={() =>dispatch('inflate', power)inflate(power)}> inflate </button <button onclick={() =>dispatch('deflate', power)deflate(power)}> deflate <button onclick={() => power--}>-</button Pump power: {power} <button onclick={() => power++}>+</button Bubbling events Instead of<button on:click>` to 'forward' event from element to component, component should accept `onclick` callback prop:`svelte <script> let { onclick } = $props(); <buttonon:click{onclick}> click me 'spread' event handlers onto element with other props instead of forwarding each event separately`svelte <script> let props = $props(); <button{. $$props} on:click on:keydown on:all_the_other_stuff{. props}> click me </button ### Event modifiers In Svelte 4, add event modifiers to handlers:`svelte <button on:click|once|preventDefault={handler}>. </button> Modifiers specific to `on:` do not work with modern event handlers. Adding `event. preventDefault()` inside handler preferable, logic lives in one place rather than split between handler and modifiers.event handlers are just functions, create own wrappers necessary: ```svelte <script> function once(fn) { return function (event) { if (fn) fn. call(this, event); fn = null; }; } function preventDefault(fn) { return function (event) { event. preventDefault(); fn. call(this, event); }; } </script> <button onclick={once(preventDefault(handler))}>. </button> three modifiers â€” `capture`, `passive` `nonpassive` can't be expressed as wrapper functions, need to be applied when event handler is bound than runs. For `capture`, add modifier to event name: ```svelte <button onclickcapture={. }>. </button> Changing [`passive`](https://developer. mozilla. org/en-US/docs/Web/API/EventTarget/addEventListener#using_passive_listeners) option of event handler, not to be done lightly. If use case for! need to use action to apply event handler yourself. ### Multiple event handlers In Svelte 4, possible: ```svelte <button on:click={one} on:click={two}>. </button> Duplicate attributes/properties on elements â€” includes event handlers not allowed. Instead, do this: ```svelte <button onclick={(e) => { one(e); two(e); }} >. </button> When spreading props, local event handlers must go _after_ spread, or risk being overwritten: ```svelte <button {. props} onclick={(e) => { doStuff(e); props. onclick?.(e); }} >. </button> ``` > `createEventDispatcher` was always a bit boilerplate-y: > > - import function > - call function to get a dispatch function > - call dispatch function with a string and possibly a payload > - retrieve payload other end through `. detail` property, because event itself was always a `CustomEvent` > > always possible to use component callback props, but had to listen to DOM events using `on:`, it made sense to use `createEventDispatcher` for component events due to syntactical consistency. Now have event attributes (`onclick`), it's other way around: Callback props are now more sensible thing to do. > > removal of event modifiers is changes seems like a step back for those liked shorthand syntax of event modifiers. they not used frequently, traded smaller surface area for more explicitness. Modifiers also were inconsistent, most only useable on DOM elements. > > Multiple listeners for same event no longer possible, but anti-pattern anyway, it impedes readability: if many attributes, harder to spot two handlers unless they right next to each other. It implies two handlers are independent, when in something like `event. stopImmediatePropagation()` inside `one` would prevent `two` from being called.deprecating `createEventDispatcher` `on:` directive in favour of callback props normal element properties, reduce Svelte's learning curve remove boilerplate, particularly around `createEventDispatcher` remove overhead of creating `CustomEvent` objects for events not have listeners add ability to spread event handlers add ability to know which event handlers provided to component add ability to express whether given event handler required or optional increase type safety (previously, impossible for Svelte to guarantee component didn't emit particular event) ## Snippets instead of slots In Svelte 4, content can be passed to components using slots. Svelte 5 replaces them with snippets more powerful flexible, slots deprecated in Svelte 5. They continue to work, can pass snippets to component uses slots: ```svelte <!file: Child. svelte> <slot /> <hr /> <slot name="foo" message="hello" /> ``` ```svelte <!file: Parent. svelte> <script> import Child from '. /Child. svelte'; </script> <Child> default child content {#snippet foo({ message })} message from child: {message} {/snippet} </Child> ``` (The reverse not true â€” cannot pass slotted content to component that uses [`{@render. }`](/docs/svelte/@render) tags. ) When using custom elements, should still use `<slot />` like before. In future version, Svelte removes internal version of slots, will leave those slots as-is,. output regular DOM tag instead of transforming it. ### Default content In Svelte 4, easiest way to pass piece of UI to child was using `<slot />`.Svelte 5, done using `children` prop instead, shown with{@render children()}``svelte <script> let { children } = $props(); </script> <slot /> {@render children?. ()} Multiple content placeholders multiple UI placeholders, use named slots. Svelte 5, use props instead, name them{@render. } them`svelte <script> let { header, main, footer } = $props(); </script> <header> <slot name="header" /> {@render header()} </header> <main> <slot name="main" /> {@render main()} <footer> <slot name="footer" /> {@render footer()} Passing data back up In Svelte 4, pass data to `<slot />` retrieve with `let:` in parent component. Svelte 5, snippets take on responsibility`svelte <!file: App. svelte> <script> import List from '. /List. svelte'; </script <List items={['one', 'two', 'three']}let:item> {#snippet item(text)} <span>{text}</span {/snippet} <span slot="empty">No items yet</span> {#snippet empty()}>No items {/snippet </List>`svelte <!file List. svelte> <script> let { items, item, empty} = $props(); </script> {#if items.length} <ul> {#each items as entry} <li> <slot item={entry} /> {@render item(entry)} </li> {/each} </ul> {:else} <slot name="empty" /> {@render empty?. ()} {/if} ``` > Slots were easy to get started with, but more advanced use case became, more involved and confusing syntax became: > > - `let:` syntax was confusing to it _creates_ a variable whereas all other `:` directives _receive_ a variable > scope of variable declared with `let:` wasn't clear. In example above, may look like can use `item` slot prop in `empty` slot, but not true > named slots had to be applied to element using `slot` attribute. Sometimes didn't want to create element, had to add `<svelte:fragment>` API > named slots could also be applied to component, changed semantics of where `let:` directives are available (even today maintainers often don't know which way around it works) > > Snippets solve these problems by being more readable and clear. they're more powerful allow to define sections of UI can render _anywhere_, not just passing them as props to component. ## Migration script By should a understanding of before/after and how old syntax relates to new syntax. clear migrations are technical and repetitive - you don't want to do by hand. We thought same, provide migration script to do most of migration automatically. can upgrade your project by using `npx sv migrate svelte-5`. This will do following things: - bump core dependencies in your `package.json` migrate to runes (`let` -> `$state` migrate to event attributes for DOM elements (`on:click` -> `onclick`) migrate slot creations to render tags (`<slot />` -> `{@render children()}`) migrate slot usages to snippets (`<div slot="x">. </div>` -> `{#snippet x()}<div>. </div>{/snippet}`) migrate obvious component creations (`new Component(. )` -> `mount(Component,. )`) migrate single component in VS Code through `Migrate Component to Svelte 5 Syntax` command, or in Playground through `Migrate` button. Not everything can be migrated automatically, some migrations need manual cleanup. following sections describe these in more detail. ### run migration script converts some `$:` statements to `run` function imported from `svelte/legacy`. This happens if migration script couldn't migrate statement to `$derived` concluded is side effect instead. some cases this may be wrong best to change to use `$derived` instead. other cases may be right, since `$:` statements also ran on server but `$effect` does not, isn't safe to transform it as such. Instead, `run` used as stopgap solution. `run` mimics characteristics of `$:`, runs on server once, and runs as `$effect. pre` on client (`$effect. pre` runs _before_ changes applied to DOM; likely want to use `$effect` instead).`svelte <script> import { run } from 'svelte/legacy'; run(() => { $effect(() => { // some side effect code }) </script> ### Event modifiers Event not applicable to event attributes (e. can't do `onclick|preventDefault={. }`)., migrating event directives to event attributes, need function-replacement for these modifiers. imported from `svelte/legacy`, should be migrated away from in favor of e. g. just using `event. preventDefault()`.`svelte <script> import { preventDefault } from 'svelte/legacy'; </script> <button onclick={preventDefault((event) => { event. preventDefault(); //. })} > click me </button> Things not automigrated migration script does not convert `createEventDispatcher`. need to adjust parts manually. too risky could result in breakage for users component, migration script cannot find out. migration script does not convert `beforeUpdate/afterUpdate`. doesn impossible to determine actual intent of code. rule of thumb go with combination of `$effect. pre` (runs at same time as `beforeUpdate`) and `tick` (imported from `svelte`, allows to wait until changes applied to DOM then do some work). Components are no longer classes In Svelte 3 and 4, components are classes. In Svelte 5 are functions should be instantiated differently. If need to manually instantiate components, use `mount` or `hydrate` (imported from `svelte`) instead. If see error using SvelteKit, try updating to latest version of SvelteKit first, adds support for Svelte 5.using Svelte without SvelteKit, likely have `main. js` file (or similar need to adjust import { mount } from 'svelte' import App from '. /App. svelte' const app = new App( target: document. getElementById("app") }); const app = mount(App, target: document. getElementById("app") export default app; `mount` and `hydrate` have same API. difference `hydrate` pick up Svelte's server-rendered HTML inside target hydrate. Both return object with exports component property accessors (if compiled with `accessors true`. not come with `$on`, `$set` `$destroy` methods from class component API. replacements: For `$on`, instead listening to events, pass them via `events` property on options argument. import { mount } from 'svelte' import App from '. /App. svelte' const app = new App( target: document. getElementById("app") app. $on('event', callback); const app = mount(App, target: document. getElementById("app"), events: { event: callback } For `$set`, use `$state` to create reactive property object manipulate it. If doing this inside `. js` or `. ts` file, adjust ending to include `. svelte`,. `. svelte. js` or `. svelte. ts`. import { mount } from 'svelte' import App from '. /App. svelte' const app = new App({ target: document. getElementById("app"), props: { foo: 'bar' } app.$set( foo: 'baz' }); const props = $state( foo: 'bar' app = mount(App, target: document. getElementById("app"), props props. foo = 'baz' For `$destroy`, use `unmount` instead. import { mount, unmount } from 'svelte' import App from '. /App. svelte' const app = new App( target: document. getElementById("app"), props: foo: 'bar' } app. $destroy(); const app =(App, target: document. getElementById("app") unmount(app); stop-gap-solution, use `createClassComponent` or `asClassComponent` (imported from `svelte/legacy`) instead to keep same API known from Svelte 4 after instantiating. import createClassComponent } from 'svelte/legacy' import App from '. /App. svelte' const app = new App( target: document. getElementById("app") app = createClassComponent( component: App, target: document. getElementById("app") }); export default app; If component not under control, use `compatibility. componentApi` compiler option for auto-applied backwards compatibility, code using `new Component(. )` keeps working without adjustments adds overhead to each component. add `$set` and `$on` methods for all component instances through `bind:this`. svelte. config.js export default { compilerOptions: { compatibility: { componentApi: 4 } } }; `` `mount` and `hydrate` _not_ synchronous, like `onMount` won't have called by time function returns pending block of promises not rendered yet (because `#await` waits microtask to wait for potentially immediately-resolved promise). If need guarantee, call `flushSync` (import from `'svelte'`) after calling `mount/hydrate`. ### Server API changes, components no longer have `render` method when compiled for server side rendering. Instead, pass function to `render` from `svelte/server`: ```js import { render } from 'svelte/server'; import App from '. /App. svelte'; const { html, head } = App. render({ props: { message: 'hello' }}); const { html, head } = render(App, { props: { message: 'hello' }}); In Svelte 4, rendering component to string returned CSS of all components. In Svelte 5, this no longer case by default using tooling chain care in other ways (like SvelteKit). If need CSS to be returned from `render`, set `css` compiler option to `'injected'` add `<style>` elements to `head`. Component typing changes change from classes towards functions reflected in typings: `SvelteComponent`, base class from Svelte 4, deprecated of new `Component` type defines function shape of Svelte component. To manually define component shape in `d.ts` file: import type { Component } from 'svelte'; export declare const MyComponent: Component<{ foo: string; }> declare component of certain type required import { ComponentA, ComponentB } from 'component-library'; import type { SvelteComponent } from 'svelte' import type Component } from 'svelte'; let C: typeof SvelteComponent<{ foo: string }> = $state( C: Component<{ foo: string }> = $state( Math. random() ? ComponentA : ComponentB two utility types `ComponentEvents` and `ComponentType` deprecated. `ComponentEvents` obsolete events defined as callback props, `ComponentType` obsolete new `Component` type is component type. `ComponentType<SvelteComponent<{ prop: string }>>` equivalent to `Component<{ prop: string }>`). bind:this changes components no longer classes, `bind:this` no longer returns class instance with `$set`, `$on` `$destroy` methods. only returns instance exports (`export function/const`), using `accessors` option, getter/setter-pair for each property. `<svelte:component>` no longer necessary In Svelte 4, components are _static_ render `<Thing>`, value of `Thing` changes, [nothing happens](/REMOVED). To make dynamic had to use `<svelte:component>`. no longer true in Svelte 5: ```svelte <script> import A from '. /A. svelte'; import B from '. /B.svelte'; let Thing = $state(); </script> <select bind:value={Thing}> <option value={A}>A</option> <option value={B}>B</option> </select> <Thing /> <svelte:component this={Thing} /> `` migrating, component's name should be capitalized (`Thing`) to distinguish from elements, unless using dot notation. Dot notation indicates component In Svelte 4, `<foo. bar>` create element with tag name `"foo. bar"`. In Svelte 5, `foo. bar` treated as component instead. useful inside `each` blocks: ```svelte {#each items as item} <item. component {. item. props} /> {/each} ``` Whitespace handling changed Previously, Svelte employed complicated algorithm to determine whitespace kept or not. Svelte 5 simplifies makes easier to reason developer. rules are: - Whitespace between nodes collapsed to one whitespace Whitespace at start and end of tag removed completely exceptions apply as keeping whitespace inside `pre` tags, can disable whitespace trimming by setting `preserveWhitespace` option in compiler settings or per-component basis in `<svelte:options>`. Modern browser required Svelte 5 requires modern browser (in, not Internet Explorer) for reasons uses [`Proxies`](https://developer. mozilla. org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy) elements with `clientWidth`/`clientHeight`/`offsetWidth`/` bindings use [`ResizeObserver`](https://developer. mozilla.org/en-US/docs/Web/API/ResizeObserver) rather than convoluted `<iframe>` hack - `<input type="range" bind:value={. } />` only uses `input` event listener, rather than listening for `change` events fallback `legacy` compiler option, generated bulkier IE-friendly code, no longer exists. Changes to compiler options - `false`/`true` deprecated previously) `"none"` values removed as valid values from `css` option - `legacy` option repurposed - `hydratable` option removed. Svelte components always hydratable now `enableSourcemap` option removed. Source maps always generated now, tooling can choose to ignore it `tag` option removed. Use `<svelte:options customElement="tag-name" />` inside component instead `loopGuardTimeout`, `format`, `sveltePath`, `errorMode` `varsReport` options removed `children` prop reserved Content inside component tags becomes snippet prop called `children`. have separate prop by that name. Breaking changes in runes mode Some changes only apply once component in runes mode. Bindings to component exports not allowed Exports from runes mode components cannot be bound to directly. For example, `export const foo =. ` in component `A` doing `<A bind:foo />` causes error. Use `bind:this` instead â€” `<A bind:this={a} />` â€” access export as `a. foo`. This change makes easier, enforces clear separation between props and exports. Bindings need be explicitly defined using `$bindable()` In Svelte 4 syntax, every property (declared via `export let`) is bindable, can `bind:` to it.runes mode, properties not bindable by default denote bindable props with `$bindable` rune. If bindable property has default value. `let { foo = $bindable('bar') } = $props();`), pass non-`undefined` value to property if binding. prevents ambiguous behavior parent child same value results in better performance (in Svelte 4, default value reflected back to parent, resulting in wasteful additional render cycles). `accessors` option ignored Setting `accessors` option to `true` makes properties component accessible on component instance. ```svelte <svelte:options accessors={true} /> <script> available via componentInstance. name export let name; </script runes mode, properties never accessible on component instance. use component exports instead if need to expose them.`svelte <script> let { name } = $props(); available via componentInstance. getName() export const getName = () => name; </script> Alternatively, if place instantiated under control, make use of runes inside `. js/. ts` files by adjusting ending to include `. svelte`,. `. svelte. js` or `. svelte. ts`, use `$state`: ```js import { mount } from 'svelte'; import App from '. /App. svelte' const app = new App({ target: document. getElementById("app"), props: { foo: 'bar' } }); app. foo = 'baz' const props = $state({ foo: 'bar' }); const app = mount(App, { target: document. getElementById("app"), props }); props.foo = 'baz'; `` ### `immutable` option ignored option no effect in runes mode. concept replaced by `$state` variations work. Classes no longer "auto-reactive" In Svelte 4, triggered reactivity: ```svelte <script> let foo = new Foo(); </script> <button on:click={() => (foo. value = 1)}>{foo. value}</button > ``` Svelte compiler treated assignment to `foo. value` as instruction to update anything referenced `foo`. In Svelte 5, reactivity determined at runtime than compile time, define `value` as reactive `$state` field on `Foo` class. Wrapping `new Foo()` with `$state(. )` no effect â€” only vanilla objects and arrays made deeply reactive. Touch and wheel events passive using `onwheel`, `onmousewheel`, `ontouchstart` `ontouchmove` event attributes, handlers are [passive](https://developer. mozilla. org/en-US/docs/Web/API/EventTarget/addEventListener#using_passive_listeners) to align with browser defaults. improves responsiveness browser to scroll document immediately, rather than waiting to if event handler calls `event. preventDefault()`. In rare cases to prevent event defaults, use [`on`](/docs/svelte/svelte-events#on) instead (for example inside action). Attribute/prop syntax stricter In Svelte 4, complex attribute values needn't be quoted: ```svelte <Component prop=this{is}valid /> ``` This is a footgun.In runes mode, if want to concatenate stuff must wrap value in quotes: ```svelte <Component prop="this{is}valid" /> ``` Note Svelte 5 warn if single expression wrapped in quotes, like `answer="{42}"` â€” in Svelte 6, cause value to converted to string, rather than passed as number. ### HTML structure stricter In Svelte 4, allowed to write HTML code repaired by browser when server side rendering. For example write this. ```svelte <table> <tr> <td>hi</td> </tr> </table> ```. browser auto-insert `<tbody>` element: ```svelte <table> <tbody> <tr> <td>hi</td> </tr> </tbody> </table> ``` Svelte 5 more strict about HTML structure throw compiler error in cases where browser repair DOM. ## Other breaking changes Stricter `@const` assignment validation Assignments to destructured parts of `@const` declaration no longer allowed. oversight this ever allowed. ### :is(. ) and :where(. ) are scoped Previously, Svelte did not analyse selectors inside `:is(. )` and `:where(. )`, treating them as global. Svelte 5 analyses them in context of current component., some selectors may now be treated as unused if relying on this treatment. To fix this, use `:global(. )` inside `:is(. )/:where(. )` selectors. using Tailwind's `@apply` directive, add `:global` selector to preserve rules use Tailwind-generated `:is(.)` selectors: ```css main:global{ @apply bg-blue-100 dark:bg-blue-900; } `` CSS hash position no longer deterministic Previously Svelte always insert CSS hash last. no longer guaranteed in Svelte 5. only breaking if weird css selectors](https://stackoverflow. com/questions/15670631/does-the-order-of-classes-listed-on-an-item-affect-the-css). Scoped CSS uses :where(. ) To avoid issues unpredictable specificity changes, scoped CSS selectors now use `:where(. svelte-xyz123)` selector modifiers alongside `. svelte-xyz123` (where `xyz123`, previously, hash of `<style>` contents). read more detail [here](https://github. com/sveltejs/svelte/pull/10443). need to support ancient browsers don't implement `:where`, can manually alter emitted CSS, at cost of unpredictable specificity changes: ```js // @errors: 2552 css = css. replace(/:where\((. +?)\)/, '$1'); `` Error/warning codes renamed Error warning codes renamed. Previously used dashes to separate words, now use underscores (e. foo-bar becomes foo_bar)., handful of codes reworded slightly. Reduced number of namespaces number of valid namespaces pass to compiler option `namespace` reduced to `html` (the default), `mathml` and `svg`. `foreign` namespace only useful for Svelte Native, planning to support differently in 5. x minor.beforeUpdate/afterUpdate changes `beforeUpdate` no longer runs twice on initial render if modifies variable referenced in template. `afterUpdate` callbacks in parent component now run after callbacks in child components. `beforeUpdate/afterUpdate` no longer run when component contains `<slot>` and content updated. Both functions disallowed in runes mode â€” use `$effect. pre(. )` and `$effect(. )` instead. `contenteditable` behavior change If `contenteditable` node with corresponding binding reactive value inside (example: `<div contenteditable=true bind:textContent>count is {count}</div>`), value inside contenteditable not be updated by updates to `count` because binding takes full control over content should only be updated through it. `oneventname` attributes no longer accept string values In Svelte 4, possible to specify event attributes on HTML elements as string: ```svelte <button onclick="alert('hello')">. </button> This not recommended, no longer possible in Svelte 5, properties like `onclick` replace `on:click` as mechanism for adding event handlers. `null` and `undefined` become empty string In Svelte 4, `null` and `undefined` were printed as corresponding string. In 99 out of 100 cases want this to become empty string instead, most other frameworks do., in Svelte 5, `null` and `undefined` become empty string. `bind:files` values can only be `null`, `undefined` or `FileList` now two-way binding., when setting value, needs to be either falsy (`null` or `undefined`) or of type `FileList`.Bindings react to form resets Previously, bindings not account `reset` event of forms, values could get out of sync with DOM. Svelte 5 fixes this by placing `reset` listener on document invoking bindings where necessary. `walk` no longer exported `svelte/compiler` reexported `walk` from `estree-walker` for convenience. no longer true in Svelte 5, import it directly from package instead need it. Content inside `svelte:options` forbidden In Svelte 4 could have content inside `<svelte:options />` tag. ignored, but could write something in there. In Svelte 5, content inside tag is a compiler error. `<slot>` elements in declarative shadow roots preserved Svelte 4 replaced `<slot />` tag with its own version of slots. Svelte 5 preserves them in case they a child of `<template shadowrootmode=". ">` element. `<svelte:element>` tag must be an expression In Svelte 4, `<svelte:element this="div">` is valid code. makes little sense â€” should just do `<div>`. In rare case need to use literal value for, can do this: ```svelte <svelte:element this={"div"}> ``` Svelte 4 would treat `<svelte:element this="input">` (for identically to `<input>` for determining `bind:` directives applied, Svelte 5 does not. `mount` plays transitions by default `mount` function used to render component tree plays transitions by default unless `intro` option set to `false`. different from legacy class components which, when manually instantiated, didn't play transitions by default. `<img src={. }>` and `{@html. }` hydration mismatches not repaired In Svelte 4, if value of `src` attribute or `{@html. }` tag differ between server and client (a. hydration mismatch), mismatch repaired. costly: setting `src` attribute (even if same thing) causes images and iframes to reloaded, reinserting large blob of HTML slow. mismatches rare, Svelte 5 assumes values unchanged, but in development will warn if not. To force update can do this: ```svelte <script> let { markup, src } = $props(); if (typeof window !== 'undefined') { // stash values. const initial = { markup, src }; // unset them. markup = src = undefined; $effect(() => { //. and reset after mounted markup = initial. markup; src = initial. src; }); } </script> {@html markup} <img {src} /> ``` ### Hydration works differently Svelte 5 makes use of comments during server side rendering used for more robust and efficient hydration on client., shouldn't remove comments from HTML output if intend to hydrate it, if manually authored HTML to be hydrated by Svelte component, need to adjust HTML to include comments at correct positions. ### `onevent` attributes are delegated Event attributes replace event directives: Instead of `on:click={handler}` write `onclick={handler}`. For backwards compatibility `on:event` syntax still supported behaves same as in Svelte 4. Some `onevent` attributes are delegated, need to care to not stop event propagation on those manually, they might never reach listener for this event type at root`--style-props` uses different element Svelte 5 uses extra `<svelte-css-wrapper>` element instead of `<div>` to wrap component when using CSS custom properties.
 docs/kit/60-appendix/30-migrating-to-sveltekit-2.
 title: Migrating to SvelteKit v2 Upgrading from SvelteKit version 1 to version 2 should be seamless. few breaking changes, listed here. use `npx sv migrate sveltekit-2` to migrate changes automatically. recommend upgrading to recent 1. x version before upgrading to 2. 0, take advantage of targeted deprecation warnings. recommend [updating to Svelte 4](. /svelte/v4-migration-guide) first: Later versions of SvelteKit 1. x support it, SvelteKit 2. 0 requires it. `redirect` and `error` no longer thrown by you Previously, had to `throw` values returned from `error(. )` and `redirect(. )` yourself. In SvelteKit 2 no longer case â€” calling functions sufficient.`js import { error } from '@sveltejs/kit'. throw error(500, 'something went wrong'); error(500, went wrong'); `svelte-migrate` will do these changes automatically for. If error or redirect thrown inside `try {. }` block don't do this!), distinguish them from unexpected errors using [`isHttpError`](@sveltejs-kit#isHttpError) and [`isRedirect`](@sveltejs-kit#isRedirect) imported from `@sveltejs/kit`.path required when setting cookies receiving `Set-Cookie` header doesn't specify `path`, browsers will [set cookie path](https://www. rfc-editor. org/rfc/rfc6265#section-5. 1. 4) to parent resource in question. behaviour isn't helpful or intuitive, frequently results in bugs developer expected cookie to apply to domain as whole. SvelteKit 2. 0, need to set `path` when calling `cookies. set(. )`, `cookies. delete(. )` or `cookies. serialize(. )` no ambiguity. time, want use `path: '/'`, can set it to whatever you like, including relative paths â€” `''` means 'the current path', `'. '` means 'the current directory'. ```js /** @type {import('. /$types'). PageServerLoad} * export function load({ cookies }) { cookies. set(name, value, { path: '/' }); return { response } } `svelte-migrate` add comments highlighting locations need to be adjusted. Top-level promises no longer awaited In SvelteKit version 1, if top-level properties object returned from `load` function were promises, automatically awaited. introduction of [streaming](/blog/streaming-snapshots-sveltekit) behavior became awkward forces to nest streamed data one level deep. of version 2, SvelteKit no longer differentiates between top-level and non-top-level promises. To get back blocking behavior, use `await` (with `Promise. all` to prevent waterfalls, appropriate): ```js // @filename: ambient. declare const url: string; @filename: index. js //cut If single promise /** @type {import('./$types'). PageServerLoad} exportasyncfunction load({ fetch }) const response =awaitfetch(url). then(r => r. json()); return { response } @filename: ambient. d. declare const url1: string; const url2: string; @filename: index. js multiple promises @type {import('. /$types'). PageServerLoad} exportasyncfunction load({ fetch }) const a = fetch(url1). then(r => r. json()); const b = fetch(url2). then(r => r. json()); const [a, b] = await Promise. all([ fetch(url1). then(r => r. json()), fetch(url2). then(r => r. json()), ]); return { a, b } goto(. ) changes `goto(. )` no longer accepts external URLs. To navigate to external URL, use `window. location. href =`. `state` object determines `$page. state` must adhere to `App. PageState` interface, if declared. See [shallow routing](shallow-routing) for more details. paths now relative by default In SvelteKit 1, `%sveltekit. assets%` in `app. html` replaced with relative path by default. `. `. ` /, depending on path rendered during server-side rendering unless [`paths. relative`](configuration#paths) option set to `false`. same true for `base` and `assets` imported from `$app/paths`, only if `paths. relative` option set to `true`.inconsistency fixed in version 2. Paths are either always relative or always absolute, depending on value of [`paths. relative`](configuration#paths). It defaults to `true` results in more portable apps: if `base` is other than app expected (as viewed on [Internet Archive](https://archive. org/), for) or unknown at build time (as when deploying to [IPFS](https://ipfs. tech/)), fewer things likely to break. Server fetches not trackable Previously possible to track URLs from `fetch`es on server to rerun load functions. poses possible security risk (private URLs leaking), was behind `dangerZone. trackServerFetches` setting, now removed. `preloadCode` arguments must be prefixed with `base` SvelteKit exposes two functions, [`preloadCode`]($app-navigation#preloadCode) and [`preloadData`]($app-navigation#preloadData), for programmatically loading code and data associated with particular path. In version 1, subtle inconsistency â€” path passed to `preloadCode` did not need to be prefixed with `base` path (if set), path passed to `preloadData` did. fixed in SvelteKit 2 â€” in both cases, path should be prefixed with `base` if set., `preloadCode` now takes single argument rather than _n_ arguments. ## `resolvePath` removed SvelteKit 1 included function called `resolvePath` allows to resolve route ID (like `/blog/[slug]`) and set of parameters (like ` slug: 'hello' }`) to pathname. return value didn't include `base` path, limiting its usefulness in cases where `base` was set., SvelteKit 2 replaces `resolvePath` with better function `resolveRoute`, imported from `$app/paths` takes `base` into account. import { resolvePath } from '@sveltejs/kit'; import { base } from '$app/paths'; import { resolveRoute } from '$app/paths'; const path = base + resolvePath('/blog/[slug]', { slug }); const path = resolveRoute('/blog/[slug]', { slug }); `svelte-migrate` will method replacement for you, if you prepend result with `base`, you need to remove that yourself. Improved error handling Errors handled inconsistently in SvelteKit 1. Some errors trigger `handleError` hook no good way to discern their status (for, only way to tell a 404 from a 500 is by seeing if `event. route. id` is `null`), others (such 405 errors for `POST` requests to pages without actions) don't trigger `handleError`, but should., resulting `$page. error` will deviate from [`App. Error`](types#Error) type, if it specified. SvelteKit 2 cleans this up by calling `handleError` hooks with two new properties: `status` and `message`. For errors thrown from your code library code) status will be `500` message be `Internal Error`. `error. message` may contain sensitive information, `message` is safe.Dynamic environment variables be used during prerendering `$env/dynamic/public` and `$env/dynamic/private` modules provide access to _run time_ environment variables, as opposed to _build time_ environment variables exposed by `$env/static/public` and `$env/static/private`. During prerendering in SvelteKit 1, they are one and the same., prerendered pages 'dynamic' environment variables 'baking in' build time values, incorrect., `$env/dynamic/public` populated in browser with stale values if user on prerendered page before navigating to dynamically-rendered pages., dynamic environment variables can no longer be read during prerendering in SvelteKit 2 â€” should use `static` modules instead. If user lands on prerendered page, SvelteKit will request up-to-date values for `$env/dynamic/public` from server (by default from module `/_app/env. js`) instead of reading from server-rendered HTML. `form` and `data` removed from `use:enhance` callbacks If callback to [`use:enhance`](form-actions#Progressive-enhancement-use:enhance), it will be called with object containing useful properties. In SvelteKit 1, properties included `form` and `data`. These deprecated in favour of `formElement` and `formData`, removed altogether in SvelteKit 2. Forms containing file inputs must use `multipart/form-data` If form contains `<input type="file">` but `enctype="multipart/form-data"` attribute, non-JS submissions will omit the file.SvelteKit 2 throw error if encounters form like this during `use:enhance` submission to ensure forms work correctly when JavaScript not present. Generated `tsconfig. json` more strict Previously, generated `tsconfig. json` to produce valid config when `tsconfig. json` included `paths` or `baseUrl`. In SvelteKit 2, validation more strict warn when use either `paths` or `baseUrl` in `tsconfig. json`. settings used to generate path aliases use [the `alias` config](configuration#alias) option in `svelte. config. js` instead, to create corresponding alias for bundler. `getRequest` no longer throws errors `@sveltejs/kit/node` module exports helper functions for in Node environments, including `getRequest` turns Node [`ClientRequest`](https://nodejs. org/api/http. html#class-httpclientrequest) into standard [`Request`](https://developer. mozilla. org/en-US/docs/Web/API/Request) object. In SvelteKit 1, `getRequest` could throw if `Content-Length` header exceeded specified size limit. In SvelteKit 2, error not thrown until later, when request body (if) read. enables better diagnostics simpler code. `vitePreprocess` no longer exported from `@sveltejs/kit/vite` Since `@sveltejs/vite-plugin-svelte` now a peer dependency, SvelteKit 2 no longer re-exports `vitePreprocess`. import it directly from `@sveltejs/vite-plugin-svelte`. Updated dependency requirements SvelteKit 2 requires Node `18.13` or higher, minimum dependency versions: - `svelte@4` - `vite@5` - `typescript@5` - `@sveltejs/vite-plugin-svelte@3` (this now required as `peerDependency` of SvelteKit previously directly depended upon) - `@sveltejs/adapter-cloudflare@3` (if using these adapters) - `@sveltejs/adapter-cloudflare-workers@2` - `@sveltejs/adapter-netlify@3` - `@sveltejs/adapter-node@2` - `@sveltejs/adapter-static@3` - `@sveltejs/adapter-vercel@4` `svelte-migrate` update `package. json` for. TypeScript upgrade, generated `tsconfig. json` `tsconfig.` extends from) now uses `"moduleResolution": "bundler"` (which recommended by TypeScript team, resolves types from packages with `exports` map in package. json) and `verbatimModuleSyntax` (which replaces existing `importsNotUsedAsValues ` and `preserveValueImports` flags in `tsconfig. json`, remove them. `svelte-migrate` will do this for). ## SvelteKit 2. 12: $app/stores deprecated SvelteKit 2. 12 introduced `$app/state` based on [Svelte 5 runes API](/docs/svelte/what-runes). `$app/state` provides everything `$app/stores` provides more flexibility where how use it., `page` object now fine-grained,. updates to `page. state` not invalidate `page. data` and vice-versa., `$app/stores` deprecated to removed in SvelteKit 3. recommend [upgrading to Svelte 5](/docs/svelte/v5-migration-guide), if migrate away from `$app/stores`. replacements simple: Replace `$app/stores` import with `$app/state` remove `$` prefixes from usage sites. ```svelte <script> import { page } from '$app/stores'; import { page } from '$app/state'; </script> {$page. data} {page. data} ``` Use `npx sv migrate app-state` to auto-migrate `$app/stores` usages inside `. svelte` components.
 Instructions for LLMs: <SYSTEM use Svelte 5 runes and Svelte 5 syntax. Runes do not need to be imported, globals. $state() runes declared using `let`, never with `const`. When passing function to $derived, use $derived. by(() =>. ). Error boundaries only catch errors during component rendering at top level of $effect inside error boundary. Error boundaries not catch errors in onclick or other event handlers. </SYSTEM>